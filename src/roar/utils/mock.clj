(ns roar.utils.mock)
(require '[roar.utils.byte :as byte])
(require '[roar.protocol :as protocol])


(defn generate-packet
  []
  (byte-array
    [
     (int 110)
     (int 65)
     (int 2)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 66)
     (int 1)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 30)
     (int 97)
     (int 97)
     (int 97)
     (int 49)
     (int 50)
     (int 51)
     (int 52)
     (int 53)
     (int 54)
     (int 55)
     (int 56)
     (int 57)
     (int 49)
     (int 50)
     (int 51)
     (int 52)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 0)
     (int 31)
     (int 49)
     (int 50)
     (int 51)
     (int 52)
     (int 53)
     (int 54)
     (int 55)
     (int 56)
     (int 57)
     (int 49)
     (int 50)
     (int 51)
     (int 97)
     (int 97)
     (int 97)
     (int 97)
     (int 97)
     (int 10)
     ]))

(defn parse-raw-frame
  []
  (let
    [
     package (protocol/to-vec (generate-packet))
     id      (byte/bytes-to-int (subvec package 0 2))
     command (byte/bytes-to-int (subvec package 2 3))
     length  (byte/bytes-to-int (subvec package 3 35))
     data    (protocol/parse-data (subvec package 35 (+ 35 length)))
     ]
    (conj
      {
       :id      id
       :command command
       :length  length
       :data    data
       })
    ))
